# Лабораторная работа №6. Многопоточные Android приложения.

## Цели
Получить практические навыки разработки многопоточных приложений:
1. Организация обработки длительных операций в background (worker) thread:
    * Запуск фоновой операции (coroutine/asynctask/thread)
    * Остановка фоновой операции (coroutine/asynctask/thread)
1. Публикация данных из background (worker) thread в main (ui) thread.

Освоить 3 основные группы API для разработки многопоточных приложений:
1. Kotlin Coroutines
1. AsyncTask
1. Java Threads

## Задачи

### Задача 1. Альтернативные решения задачи "не секундомер" из Лаб. 2
Используйте приложение "не секундомер", получившееся в результате выполнениня [Лабораторной работы №2](../02/TASK.md). Разработайте несколько альтернативных приложений "не секундомер", отличающихся друг от друга организацией многопоточной работы. Опишите все известные Вам решения.

### Задача 2. Загрузка картинки в фоновом потоке (AsyncTask) 
Создайте приложение, которое скачивает картинку из интернета и размещает ее в `ImaveView` в `Activity`. За основу возьмите [код со StackOverflow](https://stackoverflow.com/a/9288544).

### Задача 3. Загрузка картинки в фоновом потоке (Kotlin Coroutines) 
Перепишите предыдущее приложение с использованием Kotlin Coroutines.

### Задача 4. Использование сторонних библиотек 
Многие "стандартные" задачи имеют "стандартные" решения. Задача скачивания изображения в фоне возникает настолько часто, что уже сравнительно давно решение этой задачи занимает всего лишь несколько строчек. Убедитесь в этом на примере одной (любой) библиотеки [Glide](https://github.com/bumptech/glide#how-do-i-use-glide), [picasso](https://square.github.io/picasso/) или [fresco](https://frescolib.org/docs/index.html).

## Выполнение работы

### Задача 1

### Java Threads

Это код из lab2, было проверено, что не появляется более одного потока для подсчёта времени при повороте экрана.

```kotlin
package ru.spbstu.icc.kspt.lab2.continuewatch

import android.content.SharedPreferences
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import kotlinx.android.synthetic.main.activity_main.*

class JavaThreads : AppCompatActivity() {
    var secondsElapsed: Int = 0
    var work = true
    private lateinit var state: SharedPreferences
    var backgroundThread = Thread {
        while (work) {
            Thread.sleep(1000)
            textSecondsElapsed.post {
                textSecondsElapsed.setText("Seconds elapsed: " + secondsElapsed++)
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d("test", "onCreate()")
        backgroundThread.start()
        state = applicationContext.getSharedPreferences("state",
            MODE_PRIVATE)
    }

    override fun onResume() {
        super.onResume()
        Log.d("test", "onResume()")
        secondsElapsed = state.getInt("seconds", 0)
        work = true

    }

    override fun onPause() {
        super.onPause()
        Log.d("test", "onPause()")
        work = false
        val save = state.edit()
        save.putInt("seconds", secondsElapsed)
        save.apply()
    }
}
```

### Async Task

Были использованы материалы https://developer.android.com/reference/kotlin/android/os/AsyncTask , http://developer.alexanderklimov.ru/android/theory/asynctask.php

AsyncTask будет каждую секунду вызывать функцию onProgressUpdate(), которая и будет обновлять счётчик времени. Было проверено, что не появляется более одного потока для подсчёта времени при повороте экрана.

```kotlin
package ru.spbstu.icc.kspt.lab2.continuewatch

import android.content.SharedPreferences
import android.os.AsyncTask
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
import java.util.concurrent.TimeUnit

class AsyncTask : AppCompatActivity() {
    var secondsElapsed: Int = 0
    private lateinit var state: SharedPreferences
    private lateinit var timerAsyncTask: TimerAsyncTask

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        state = applicationContext.getSharedPreferences(
            "state",
            MODE_PRIVATE
        )
    }

    override fun onStart() {
        super.onStart()
        if (state.contains("seconds")) {
            secondsElapsed = state.getInt("seconds", 0)
            textSecondsElapsed.post {
                textSecondsElapsed.setText("Seconds elapsed: " + secondsElapsed++)
            }
        }
    }

    override fun onResume() {
        timerAsyncTask = TimerAsyncTask()
        timerAsyncTask.execute()
        super.onResume()
    }

    override fun onPause() {
        super.onPause()
        state.edit().putInt("seconds", secondsElapsed).apply()
    }

    inner class TimerAsyncTask : AsyncTask<Void, Void, Void>() {
        override fun doInBackground(vararg params: Void?): Void? {
            while (!isCancelled) {
                TimeUnit.SECONDS.sleep(1)
                publishProgress()
            }
            return null
        }

        override fun onProgressUpdate(vararg values: Void?) {
            super.onProgressUpdate(*values)
            textSecondsElapsed.setText("Seconds elapsed: " + secondsElapsed++)
        }
    }
}
```
### Kotlin Coroutines

Были задействованы материалы https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/, https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope , https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html

В onResume запускаем таймер, который каждую секунду будет обновляться счётчик времени. Было проверено, что не появляется более одного потока для подсчёта времени при повороте экрана.

```kotlin
package ru.spbstu.icc.kspt.lab2.continuewatch

import android.content.SharedPreferences
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.coroutines.*

class Coroutines : AppCompatActivity() {
    var secondsElapsed: Int = 0
    private lateinit var state: SharedPreferences
    private lateinit var timer: Job
    private val Scope = CoroutineScope(Dispatchers.Main)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        state = applicationContext.getSharedPreferences(
            "state",
            MODE_PRIVATE
        )
    }

    override fun onStart() {
        super.onStart()
        if (state.contains("seconds")) {
            secondsElapsed = state.getInt("seconds", 0)
            textSecondsElapsed.post {
                textSecondsElapsed.setText("Seconds elapsed: " + secondsElapsed++)
            }
        }
    }

    override fun onResume() {
        timer = Scope.launch {
            while (true) {
                delay(1000)
                textSecondsElapsed.setText("Seconds elapsed: " + secondsElapsed++)
            }
        }
        super.onResume()
    }

    override fun onPause() {
        timer.cancel()
        super.onPause()
    }

}
```
